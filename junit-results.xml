<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite errors="0" failures="1" hostname="Alexs-MacBook-Pro.local" name="pytest" skipped="0" tests="1" time="39.464" timestamp="2020-08-17T19:10:13.831662"><testcase classname="pd_parser.tests.test_parse_pd" file="pd_parser/tests/test_parse_pd.py" line="50" name="test_parse_pd" time="37.030"><failure message="ValueError: This function cannot change to this channel type: grad. Accepted channel types are bio, ecg, ecog, eeg, emg, eog, exci, fnirs_od, fnirs_raw, hbo, hbr, ias, misc, resp, seeg, stim, syst.">_bids_validate = &lt;function _bids_validate.&lt;locals&gt;._validate at 0x7f9b096437a0&gt;

    @pytest.mark.filterwarnings(&apos;ignore::RuntimeWarning&apos;)
    @pytest.mark.filterwarnings(&apos;ignore::DeprecationWarning&apos;)
    def test_parse_pd(_bids_validate):
        # load in data
        out_dir = _TempDir()
        fname = op.join(out_dir, &apos;pd_data-raw.fif&apos;)
        behf = op.join(basepath, &apos;pd_beh.tsv&apos;)
        events = _read_tsv(op.join(basepath, &apos;pd_events.tsv&apos;))
        events_relative = _read_tsv(op.join(basepath, &apos;pd_events_relative.tsv&apos;))
    
        raw_tmp = mne.io.read_raw_fif(op.join(basepath, &apos;pd_data-raw.fif&apos;),
                                      preload=True)
        info = mne.create_info([&apos;ch1&apos;, &apos;ch2&apos;, &apos;ch3&apos;], raw_tmp.info[&apos;sfreq&apos;],
                               [&apos;grad&apos;] * 3)
        raw_tmp2 = \
            mne.io.RawArray(np.random.random((3, raw_tmp.times.size)) * 1e-10,
                            info)
        raw_tmp2.info[&apos;lowpass&apos;] = raw_tmp.info[&apos;lowpass&apos;]
        raw_tmp.add_channels([raw_tmp2])
        raw_tmp.info[&apos;dig&apos;] = None
        raw_tmp.info[&apos;line_freq&apos;] = 60
        raw_tmp.save(fname)
        # this needs to be tested with user interaction, this
        # just tests that it launches
        pd_parser.find_pd_params(fname, pd_ch_names=[&apos;pd&apos;])
        # test core functionality
        pd_parser.parse_pd(fname, behf=behf, pd_ch_names=[&apos;pd&apos;],
                           alignment_prop=0.05)  # reduce alignment_prop -&gt; faster
        raw = mne.io.read_raw_fif(fname)
        annot, pd_ch_names, beh_df = _load_pd_data(fname)
        raw.set_annotations(annot)
        events2, event_id = mne.events_from_annotations(raw)
        assert all(events2[:, 0] == events[&apos;pd_sample&apos;])
        assert pd_ch_names == [&apos;pd&apos;]
        event_indices = [i for i, s in enumerate(beh_df[&apos;pd_sample&apos;])
                         if s != &apos;n/a&apos;]
        assert event_indices == events[&apos;trial&apos;]
        assert all([beh_df[&apos;pd_sample&apos;][j] == events[&apos;pd_sample&apos;][i]
                    for i, j in enumerate(event_indices)])
        # test add_pd_relative_events
        pd_parser.add_pd_relative_events(
            fname, behf,
            relative_event_cols=[&apos;fix_duration&apos;, &apos;go_time&apos;, &apos;response_time&apos;],
            relative_event_names=[&apos;ISI Onset&apos;, &apos;Go Cue&apos;, &apos;Response&apos;])
        annot, pd_ch_names, beh_df = _load_pd_data(fname)
        raw.set_annotations(annot)
        events2, event_id = mne.events_from_annotations(raw)
        assert all(events2[:, 0] == events_relative[&apos;sample&apos;])
        assert pd_ch_names == [&apos;pd&apos;]
        assert all(events2[:, 2] == [event_id[tt] for tt in
                                     events_relative[&apos;trial_type&apos;]])
        # test add_pd_events_to_raw
        out_fname = pd_parser.add_pd_events_to_raw(fname, drop_pd_channels=False)
        raw2 = mne.io.read_raw_fif(out_fname)
        events3, event_id2 = mne.events_from_annotations(raw2)
        np.testing.assert_array_equal(events3, events2)
        assert event_id2 == event_id
        # test pd_parser_save_to_bids
        bids_dir = op.join(out_dir, &apos;bids_dir&apos;)
        pd_parser.pd_parser_save_to_bids(bids_dir, fname, &apos;1&apos;, &apos;test&apos;,
&gt;                                        data_type=&apos;grad&apos;, verbose=False)

_bids_validate = &lt;function _bids_validate.&lt;locals&gt;._validate at 0x7f9b096437a0&gt;
annot      = &lt;Annotations | 1153 segments: Fixation (290), Go Cue (290), ISI Onset ...&gt;
beh_df     = {&apos;fix_duration&apos;: [0.6, 0.7, 0.4, 0.4, 0.5, 0.7, ...], &apos;fix_onset_time&apos;: [40923.295, 40931.0775, 40938.977, 40946.7271,...9, 1.4318, 1.3289, 1.0254, 1.4241, 1.5237, ...], &apos;pd_sample&apos;: [202969, &apos;n/a&apos;, &apos;n/a&apos;, 226292, 233755, 241635, ...], ...}
behf       = &apos;/Users/alexrockhill/projects/pd-parser/pd_parser/tests/data/pd_beh.tsv&apos;
bids_dir   = &apos;/var/folders/s4/y1vlkn8d70jfw7s8s03m9p540000gn/T/tmp_mne_tempdir_mj_if98c/bids_dir&apos;
event_id   = {&apos;Fixation&apos;: 1, &apos;Go Cue&apos;: 2, &apos;ISI Onset&apos;: 3, &apos;Response&apos;: 4}
event_id2  = {&apos;Fixation&apos;: 1, &apos;Go Cue&apos;: 2, &apos;ISI Onset&apos;: 3, &apos;Response&apos;: 4}
event_indices = [0, 3, 4, 5, 6, 7, ...]
events     = {&apos;pd_sample&apos;: [202969, 226292, 233755, 241635, 249598, 257361, ...], &apos;trial&apos;: [0, 3, 4, 5, 6, 7, ...]}
events2    = array([[ 202969,       0,       1],
       [ 203569,       0,       3],
       [ 204303,       0,       2],
       ...,
       [2636340,       0,       3],
       [2636971,       0,       2],
       [2637579,       0,       4]])
events3    = array([[ 202969,       0,       1],
       [ 203569,       0,       3],
       [ 204303,       0,       2],
       ...,
       [2636340,       0,       3],
       [2636971,       0,       2],
       [2637579,       0,       4]])
events_relative = {&apos;duration&apos;: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ...], &apos;onset&apos;: [203.08839352941175, 203.68874647058823, 204.4231782352941,...226292, 226692, ...], &apos;trial_type&apos;: [&apos;Fixation&apos;, &apos;ISI Onset&apos;, &apos;Go Cue&apos;, &apos;Response&apos;, &apos;Fixation&apos;, &apos;ISI Onset&apos;, ...], ...}
fname      = &apos;/var/folders/s4/y1vlkn8d70jfw7s8s03m9p540000gn/T/tmp_mne_tempdir_mj_if98c/pd_data-raw.fif&apos;
info       = &lt;Info | 7 non-empty values
 bads: []
 ch_names: ch1, ch2, ch3
 chs: 3 GRAD
 custom_ref_applied: False
 highpass: 0.0 Hz
 lowpass: 499.7 Hz
 meas_date: unspecified
 nchan: 3
 projs: []
 sfreq: 999.4 Hz
&gt;
out_dir    = &apos;/var/folders/s4/y1vlkn8d70jfw7s8s03m9p540000gn/T/tmp_mne_tempdir_mj_if98c&apos;
out_fname  = &apos;/var/folders/s4/y1vlkn8d70jfw7s8s03m9p540000gn/T/tmp_mne_tempdir_mj_if98c/pd_data-rawpd_raw.fif&apos;
pd_ch_names = [&apos;pd&apos;]
raw        = &lt;Raw | pd_data-raw.fif, 4 x 2818158 (2819.8 s), ~13 kB, data not loaded&gt;
raw2       = &lt;Raw | pd_data-rawpd_raw.fif, 4 x 2818158 (2819.8 s), ~13 kB, data not loaded&gt;
raw_tmp    = &lt;Raw | pd_data-raw.fif, 4 x 2818158 (2819.8 s), ~86.0 MB, data loaded&gt;
raw_tmp2   = &lt;RawArray | 3 x 2818158 (2819.8 s), ~64.5 MB, data loaded&gt;

pd_parser/tests/test_parse_pd.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
pd_parser/parse_pd.py:790: in pd_parser_save_to_bids
    raw.set_channel_types({ch: data_type for ch in raw.ch_names if
        aux_chs    = []
        bids_basename = &apos;sub-1_task-test&apos;
        bids_beh_dir = &apos;/var/folders/s4/y1vlkn8d70jfw7s8s03m9p540000gn/T/tmp_mne_tempdir_mj_if98c/bids_dir/sub-1/beh&apos;
        bids_dir   = &apos;/var/folders/s4/y1vlkn8d70jfw7s8s03m9p540000gn/T/tmp_mne_tempdir_mj_if98c/bids_dir&apos;
        ch_list    = None
        data_type  = &apos;grad&apos;
        ecgs       = None
        emgs       = None
        eogs       = None
        fname      = &apos;/var/folders/s4/y1vlkn8d70jfw7s8s03m9p540000gn/T/tmp_mne_tempdir_mj_if98c/pd_data-raw.fif&apos;
        mne_bids   = &lt;module &apos;mne_bids&apos; from &apos;/Users/alexrockhill/software/mne-bids/mne_bids/__init__.py&apos;&gt;
        name       = &apos;emg&apos;
        overwrite  = False
        raw        = &lt;Raw | pd_data-raw.fif, 4 x 2818158 (2819.8 s), ~13 kB, data not loaded&gt;
        run        = None
        ses        = None
        sub        = &apos;1&apos;
        task       = &apos;test&apos;
        verbose    = False
&lt;decorator-gen-31&gt;:21: in set_channel_types
    ???
        mapping    = {&apos;ch1&apos;: &apos;grad&apos;, &apos;ch2&apos;: &apos;grad&apos;, &apos;ch3&apos;: &apos;grad&apos;, &apos;pd&apos;: &apos;grad&apos;}
        self       = &lt;Raw | pd_data-raw.fif, 4 x 2818158 (2819.8 s), ~13 kB, data not loaded&gt;
        verbose    = None
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Raw | pd_data-raw.fif, 4 x 2818158 (2819.8 s), ~13 kB, data not loaded&gt;
mapping = {&apos;ch1&apos;: &apos;grad&apos;, &apos;ch2&apos;: &apos;grad&apos;, &apos;ch3&apos;: &apos;grad&apos;, &apos;pd&apos;: &apos;grad&apos;}, verbose = None

    @verbose
    def set_channel_types(self, mapping, verbose=None):
        &quot;&quot;&quot;Define the sensor type of channels.
    
        Parameters
        ----------
        mapping : dict
            A dictionary mapping a channel to a sensor type (str), e.g.,
            ``{&apos;EEG061&apos;: &apos;eog&apos;}``.
        %(verbose_meth)s
    
        Returns
        -------
        inst : instance of Raw | Epochs | Evoked
            The instance (modified in place).
    
            .. versionchanged:: 0.20
               Return the instance.
    
        Notes
        -----
        The following sensor types are accepted:
    
            ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog,
            hbo, hbr, fnirs_raw, fnirs_od
    
        .. versionadded:: 0.9.0
        &quot;&quot;&quot;
        ch_names = self.info[&apos;ch_names&apos;]
    
        # first check and assemble clean mappings of index and name
        unit_changes = dict()
        for ch_name, ch_type in mapping.items():
            if ch_name not in ch_names:
                raise ValueError(&quot;This channel name (%s) doesn&apos;t exist in &quot;
                                 &quot;info.&quot; % ch_name)
    
            c_ind = ch_names.index(ch_name)
            if ch_type not in _human2fiff:
                raise ValueError(&apos;This function cannot change to this &apos;
                                 &apos;channel type: %s. Accepted channel types &apos;
                                 &apos;are %s.&apos;
                                 % (ch_type,
&gt;                                   &quot;, &quot;.join(sorted(_human2unit.keys()))))
E               ValueError: This function cannot change to this channel type: grad. Accepted channel types are bio, ecg, ecog, eeg, emg, eog, exci, fnirs_od, fnirs_raw, hbo, hbr, ias, misc, resp, seeg, stim, syst.

c_ind      = 0
ch_name    = &apos;pd&apos;
ch_names   = [&apos;pd&apos;, &apos;ch1&apos;, &apos;ch2&apos;, &apos;ch3&apos;]
ch_type    = &apos;grad&apos;
mapping    = {&apos;ch1&apos;: &apos;grad&apos;, &apos;ch2&apos;: &apos;grad&apos;, &apos;ch3&apos;: &apos;grad&apos;, &apos;pd&apos;: &apos;grad&apos;}
self       = &lt;Raw | pd_data-raw.fif, 4 x 2818158 (2819.8 s), ~13 kB, data not loaded&gt;
unit_changes = {}
verbose    = None

../../software/anaconda3/envs/swannlab/lib/python3.7/site-packages/mne/channels/channels.py:432: ValueError</failure></testcase></testsuite></testsuites>